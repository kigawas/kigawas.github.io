<!doctype html><html lang=en><head><title>Redefining shared behaviors algebraically :: map(learn, world)</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Overview Object-oriented programming is a ubiquitous paradigm all over the software development field as it could be found in the most of prevalent languages: C++, C#, Java, JavaScript, Python, etc. Polymorphism, an important characteristic in OOP, is often implemented by sub-typing in a typical OOP language.
interface Animal { public void talk(); } class Cat implements Animal { public void talk() { System.out.println(&amp;#34;meow&amp;#34;); } } class Dog implements Animal { public void talk() { System."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/interface-vs-adt/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Redefining shared behaviors algebraically"><meta property="og:description" content="Comparison of defining shared behaviors by OOP and algebraic data types"><meta property="og:url" content="/posts/interface-vs-adt/"><meta property="og:site_name" content="map(learn, world)"><meta property="og:image" content="/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-12-28 00:00:00 +0000 UTC"></head><body class=blue><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>map(learn, world)</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/interface-vs-adt/>Redefining shared behaviors algebraically</a></h1><div class=post-meta><span class=post-date>2020-12-28 [Updated: 2021-01-10]</span></div><span class=post-tags>#<a href=/tags/rust/>Rust</a>&nbsp;
#<a href=/tags/oop/>OOP</a>&nbsp;
#<a href=/tags/algebraic-data-type/>Algebraic Data Type</a>&nbsp;
#<a href=/tags/type-system/>Type system</a>&nbsp;</span><div class=post-content><div><h2 id=overview>Overview<a href=#overview class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Object-oriented programming is a ubiquitous paradigm all over the software development field as it could be found in the most of prevalent languages: C++, C#, Java, JavaScript, Python, etc. <a href=https://en.wikipedia.org/wiki/Polymorphism_(computer_science)>Polymorphism</a>, an important characteristic in OOP, is often implemented by sub-typing in a typical OOP language.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Animal</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>talk</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cat</span> <span style=color:#66d9ef>implements</span> Animal <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>talk</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;meow&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span> <span style=color:#66d9ef>implements</span> Animal <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>talk</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;bowwow&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>The <code>interface</code>, or <code>abstract class</code> in some languages, here indicates <strong>a protocol of shared behaviors</strong>, normally there&rsquo;s no way to get access to data in the interface, thus, only a few of default behaviors can be implemented in the interface rather than in its subclasses.</p><p>In Java, interface methods cannot have body:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Shape</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printCoordinates</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// error: interface abstract methods cannot have body
</span><span style=color:#75715e></span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>format</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;(%s, %s)&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>x</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>y</span><span style=color:#f92672>));</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>In C++, interface methods can have body, but they won&rsquo;t work if there&rsquo;re no member variables.</p><blockquote><p>C++ has no pure &ldquo;interface&rdquo;, which doesn&rsquo;t allow variables. You can define variables in the abstract class willy-nilly, albeit not recommended.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> {
    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> printCoordinates() {
            <span style=color:#75715e>// error: &#39;class Shape&#39; has no member named &#39;x&#39;
</span><span style=color:#75715e></span>            <span style=color:#75715e>// error: &#39;class Shape&#39; has no member named &#39;y&#39;
</span><span style=color:#75715e></span>            printf(<span style=color:#e6db74>&#34;(%d, %d)&#34;</span>, <span style=color:#66d9ef>this</span> <span style=color:#f92672>-&gt;</span> x, <span style=color:#66d9ef>this</span> <span style=color:#f92672>-&gt;</span> y);
        }
};
</code></pre></div><blockquote><p>It&rsquo;s still possible to use <code>getters/setters</code> to interact with data indirectly in the interface, but it&rsquo;s kind of wordy.</p></blockquote><h2 id=oop-in-rust>OOP in Rust<a href=#oop-in-rust class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Rust, which also <a href=https://doc.rust-lang.org/book/ch17-00-oop.html>supports OOP</a> to some extent, allows you to define the shared behaviors with <code>trait</code> as what you would do in other languages with <code>interface</code>.</p><blockquote><p>Strictly speaking, <code>trait</code> in Rust <a href=https://blog.rust-lang.org/2015/05/11/traits.html>is different from</a> <code>interface</code> or <code>abstract class</code> in other languages, that&rsquo;s why it has a different name <code>trait</code>.</p><p>It doesn&rsquo;t matter if you don&rsquo;t know the difference while reading this article.</p><p>If you are really curious, well, the major difference is that you can implement your own <code>trait</code> for classes from third-party libraries, without changing any code in those libraries. In contrast, <code>interface</code> or <code>abstarct class</code> won&rsquo;t allow you do this normally, especially in static languages like Java or C++.</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Dog</span>;
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cat</span>;

<span style=color:#66d9ef>trait</span> IAnimal {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {}
}

<span style=color:#66d9ef>impl</span> IAnimal <span style=color:#66d9ef>for</span> Dog {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;bowwow&#34;</span>);
    }
}

<span style=color:#66d9ef>impl</span> IAnimal <span style=color:#66d9ef>for</span> Cat {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;meow&#34;</span>);
    }
}
</code></pre></div><p>So far so good. But is there a different way doing this? Before we step into the next level, several concepts need to be addressed.</p><h2 id=a-prime-of-algebraic-data-types>A prime of algebraic data types<a href=#a-prime-of-algebraic-data-types class=hanchor arialabel=Anchor>&#8983;</a></h2><p>An algebraic data type, or ADT (not to be confused with <a href=https://en.wikipedia.org/wiki/Abstract_data_type>abstract data type</a>), is a composite type. There are two common algebraic data types: sum types and product types.</p><p>Their names look mathematical, but in fact they are just very simple notions. If you know some Python, a sum type in Python is <a href=https://docs.python.org/3/library/typing.html#typing.Union><code>Union</code></a>, and a product type is <a href=https://docs.python.org/3/library/typing.html#typing.Tuple><code>Tuple</code></a>.</p><p>So why call it &ldquo;sum/product&rdquo; type? Say you have a union <code>A</code> for <code>int</code> or <code>bool</code>, <code>int</code> can only be <code>1</code>, <code>2</code> or <code>3</code> and <code>bool</code> can only be <code>True</code> or <code>False</code>, how many different objects of <code>A</code> can you get? The answer is easy: if <code>A</code> is <code>int</code>, then you have three choices; if <code>A</code> is <code>bool</code>, then two; if you add them up, you get five.</p><p>This also applies to a product type, e.g. a tuple <code>(int, bool)</code>. For the first element, you have three choices and for the second element you have two, so you have six (3 times 2): <code>(1, True)</code>, <code>(2, True)</code>, <code>(3, True)</code>, <code>(1, False)</code>, <code>(2, False)</code>, <code>(3, False)</code>.</p><p>Now everything gets clear, for a sum type <code>S = A | B</code>, an object of <code>S</code> is either <code>A</code> or <code>B</code> which means the number of different objects is the sum of <code>A</code> and <code>B</code>; for a product type <code>P = (A, B)</code>, the number of different objects is the product of <code>A</code> and <code>B</code>.</p><blockquote><p>&ldquo;The number of different objects&rdquo; is called &ldquo;cardinality&rdquo; mathematically.</p><p>If you want to know more about algebraic data types, <a href=https://fsharpforfunandprofit.com/posts/type-size-and-design/>this article</a> could be a good start.</p></blockquote><h2 id=adt-in-rust>ADT in Rust<a href=#adt-in-rust class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In Rust, the sum type is <code>enum</code> and the product type is <code>struct</code>. Unlike the <a href=https://docs.python.org/3/library/enum.html><code>enum.Enum</code></a> in Python, Rust&rsquo;s <code>enum</code> is powerful enough to be a composite of arbitrary types: <code>enum E = A | B | C | D ...</code> and <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> can also be sum types or product types.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// struct is a product type
</span><span style=color:#75715e>// here we have 2^8 * 2^8 different dogs
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Dog</span> {
    id: <span style=color:#66d9ef>u8</span>,
    age: <span style=color:#66d9ef>u8</span>,
    <span style=color:#75715e>// some extra fields can be added
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cat</span> {
    id: <span style=color:#66d9ef>u8</span>,
    age: <span style=color:#66d9ef>u8</span>,
}

<span style=color:#75715e>// sum type: Dog | Cat
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Animal</span> {
    Dog(Dog),
    Cat(Cat),
}
</code></pre></div><p>Instead of having a common interface, we implement methods for the sum type <code>Animal</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> Animal {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {
        <span style=color:#66d9ef>match</span> self {
            <span style=color:#f92672>&amp;</span>Self::Cat(_) <span style=color:#f92672>=&gt;</span> println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;meow&#34;</span>),
            <span style=color:#f92672>&amp;</span>Self::Dog(_) <span style=color:#f92672>=&gt;</span> println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;bowwow&#34;</span>),
        }
    }

    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>info</span>(<span style=color:#f92672>&amp;</span>self) {
        <span style=color:#66d9ef>match</span> self {
            <span style=color:#f92672>&amp;</span>Self::Cat(Cat { id, age }) <span style=color:#f92672>=&gt;</span> println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Cat: id: {}, age: {}&#34;</span>, id, age),
            <span style=color:#f92672>&amp;</span>Self::Dog(Dog { id, age }) <span style=color:#f92672>=&gt;</span> println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Dog: id: {}, age: {}&#34;</span>, id, age),
        }
    }
}
</code></pre></div><p>The <a href=https://doc.rust-lang.org/rust-by-example/flow_control/match.html><code>match</code></a> here stands for <a href=https://en.wikipedia.org/wiki/Pattern_matching>pattern matching</a>, which is a critical paradigm in functional programming. I&rsquo;ll omit details here, but let me just recap, you can regard it as an advanced version of <code>switch</code> in <code>C</code> and destructuring assignment in <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment>JavaScript</a> or <a href=https://blog.tecladocode.com/destructuring-in-python>Python</a>.</p><p>So, what about the OOP equivalent in Rust?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>trait</span> IAnimal {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {}
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>info</span>(<span style=color:#f92672>&amp;</span>self) {}
}

<span style=color:#66d9ef>impl</span> IAnimal <span style=color:#66d9ef>for</span> Dog {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;bowwow&#34;</span>);
    }
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>info</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Dog: id: {}, age: {}&#34;</span>, self.id, self.age);
    }
}

<span style=color:#66d9ef>impl</span> IAnimal <span style=color:#66d9ef>for</span> Cat {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>talk</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;meow&#34;</span>);
    }
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>info</span>(<span style=color:#f92672>&amp;</span>self) {
        println<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;Cat: id: {}, age: {}&#34;</span>, self.id, self.age);
    }
}
</code></pre></div><p>Obviously it&rsquo;s more verbose, specifically, we have three <code>talk</code>s and <code>info</code>s and the implementation scatters here and there. Ever worse, the <code>interface</code> implementation is not exhaustive: If we add another animal, say <code>Sheep</code>, it won&rsquo;t notice us if we haven&rsquo;t implemented <code>IAnimal</code>. But if we choose the sum type, Rust compiler will complain like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>error[E0004]: <span style=color:#a6e22e>non</span><span style=color:#f92672>-</span>exhaustive patterns: <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Sheep(_)<span style=color:#960050;background-color:#1e0010>`</span> not covered
  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>main.rs:<span style=color:#ae81ff>52</span>:<span style=color:#ae81ff>15</span>
   <span style=color:#f92672>|</span>
<span style=color:#ae81ff>43</span> <span style=color:#f92672>|</span> <span style=color:#f92672>/</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Animal</span> {
<span style=color:#ae81ff>44</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Dog(Dog),
<span style=color:#ae81ff>45</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Cat(Cat),
<span style=color:#ae81ff>46</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Sheep(Sheep),
   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     <span style=color:#f92672>-----</span> not covered
<span style=color:#ae81ff>47</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span> }
   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>_<span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>`</span>Animal<span style=color:#960050;background-color:#1e0010>`</span> defined here
...
<span style=color:#ae81ff>52</span> <span style=color:#f92672>|</span>           <span style=color:#66d9ef>match</span> self {
   <span style=color:#f92672>|</span>                 <span style=color:#f92672>^^^^</span> pattern <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Sheep(_)<span style=color:#960050;background-color:#1e0010>`</span> not covered
   <span style=color:#f92672>|</span>
   <span style=color:#f92672>=</span> help: <span style=color:#a6e22e>ensure</span> that all possible cases are being handled, possibly by adding wildcards or more <span style=color:#66d9ef>match</span> arms
   <span style=color:#f92672>=</span> note: <span style=color:#a6e22e>the</span> matched value is of <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Animal<span style=color:#960050;background-color:#1e0010>`</span>

error[E0004]: <span style=color:#a6e22e>non</span><span style=color:#f92672>-</span>exhaustive patterns: <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Sheep(_)<span style=color:#960050;background-color:#1e0010>`</span> not covered
  <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>main.rs:<span style=color:#ae81ff>58</span>:<span style=color:#ae81ff>15</span>
   <span style=color:#f92672>|</span>
<span style=color:#ae81ff>43</span> <span style=color:#f92672>|</span> <span style=color:#f92672>/</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Animal</span> {
<span style=color:#ae81ff>44</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Dog(Dog),
<span style=color:#ae81ff>45</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Cat(Cat),
<span style=color:#ae81ff>46</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     Sheep(Sheep),
   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>     <span style=color:#f92672>-----</span> not covered
<span style=color:#ae81ff>47</span> <span style=color:#f92672>|</span> <span style=color:#f92672>|</span> }
   <span style=color:#f92672>|</span> <span style=color:#f92672>|</span>_<span style=color:#f92672>-</span> <span style=color:#960050;background-color:#1e0010>`</span>Animal<span style=color:#960050;background-color:#1e0010>`</span> defined here
...
<span style=color:#ae81ff>58</span> <span style=color:#f92672>|</span>           <span style=color:#66d9ef>match</span> self {
   <span style=color:#f92672>|</span>                 <span style=color:#f92672>^^^^</span> pattern <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Sheep(_)<span style=color:#960050;background-color:#1e0010>`</span> not covered
   <span style=color:#f92672>|</span>
   <span style=color:#f92672>=</span> help: <span style=color:#a6e22e>ensure</span> that all possible cases are being handled, possibly by adding wildcards or more <span style=color:#66d9ef>match</span> arms
   <span style=color:#f92672>=</span> note: <span style=color:#a6e22e>the</span> matched value is of <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span><span style=color:#f92672>&amp;</span>Animal<span style=color:#960050;background-color:#1e0010>`</span>

error: <span style=color:#a6e22e>aborting</span> due to <span style=color:#ae81ff>2</span> previous errors
</code></pre></div><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In this article, we revisited a common OOP polymorphism paradigm, which is defining shared behaviors by sub-typing interfaces, and came up with another strategy to achieve the same goal via ADTs. By leveraging the type system and pattern matching of Rust, we are capable of defining shared behaviors with less code and more confidence.</p><blockquote><p>ADT is not a silver bullet, but it&rsquo;s a functional way of implementing polymorphism and can be useful in some scenarios.</p></blockquote><p>The Rust code above can be found in the <a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c8640c555fce2ec520d23d446b686d3e">Playground</a>.</p></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//kigawas-blog.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>Â© 2021 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>