<!doctype html><html lang=en><head><title>Y-combinator in Python :: map(learn, world)</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A brief introduction to lambda calculus Lambda calculus is a language (formal system) to abstract and express calculation itself under only three concise rules.
   Syntax Name Description     x Variable Representing some value   (λx. M) Abstraction Defining a function, M is also an expression of lambda calculus   (M N) Application Calling a function, M and N are expressions of lambda calculus     In lambda calculus, we can say &amp;ldquo;applying/calling/invoking a function&amp;rdquo; interchangeably."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/y-combinator-in-python/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/assets/blue.css><link rel=apple-touch-icon href=/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Y-combinator in Python"><meta property="og:description" content="A brief introduction to Y-combinator in Python"><meta property="og:url" content="/posts/y-combinator-in-python/"><meta property="og:site_name" content="map(learn, world)"><meta property="og:image" content="/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2018-11-22 00:00:00 +0000 UTC"></head><body class=blue><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>map(learn, world)</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/projects>Projects</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=/posts/y-combinator-in-python/>Y-combinator in Python</a></h1><div class=post-meta><span class=post-date>2018-11-22 [Updated: 2021-03-18]</span></div><span class=post-tags>#<a href=/tags/python/>Python</a>&nbsp;
#<a href=/tags/functional-programming/>functional programming</a>&nbsp;</span><div class=post-content><div><h2 id=a-brief-introduction-to-lambda-calculus>A brief introduction to lambda calculus<a href=#a-brief-introduction-to-lambda-calculus class=hanchor arialabel=Anchor>&#8983;</a></h2><p><a href=https://en.wikipedia.org/wiki/Lambda_calculus>Lambda calculus</a> is a language (formal system) to abstract and express calculation itself under only three concise rules.</p><table><thead><tr><th>Syntax</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>x</td><td>Variable</td><td>Representing some value</td></tr><tr><td>(λx. M)</td><td>Abstraction</td><td>Defining a function, M is also an expression of lambda calculus</td></tr><tr><td>(M N)</td><td>Application</td><td>Calling a function, M and N are expressions of lambda calculus</td></tr></tbody></table><blockquote><p>In lambda calculus, we can say &ldquo;applying/calling/invoking a function&rdquo; interchangeably.</p></blockquote><h2 id=what-is-y-combinator>What is Y-combinator<a href=#what-is-y-combinator class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In terms of the functional programming field, <a href=https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed_point_combinators_in_lambda_calculus>Y-combinator</a> is expressed on the lambda calculus format: <code>λf. (λx. (f (x x))) (λx. (f (x x)))</code>.</p><p>With Y-combinator, we can implement recursion <strong>without defining functions explicitly</strong>. As you may know, recursion is equivalent to iteration, thus we can assure that lambda calculus is as powerful as Python (lambda calculus is Turing-complete per se), even it only has three rules compared to some sophisticated languages.</p><p>In this article, we&rsquo;ll discuss how to do it in Python.</p><h2 id=how-to-implement-y-combinator>How to implement Y-combinator<a href=#how-to-implement-y-combinator class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Let&rsquo;s break the daunting lambda expression into smaller pieces. For simplicity, it can be split into two parts: inner and outer.</p><p>First, let&rsquo;s have a look at the outer side. It&rsquo;s actually accepting an argument <code>f</code> and returning the result of <code>λx. (f (x x))</code> invoked with the argument <code>λx. (f (x x))</code>.</p><h3 id=inner-lambda>Inner lambda<a href=#inner-lambda class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If you have some experience of Lisp-family languages, you may be familiar with something like <code>(f (x x))</code>, which is also called &ldquo;<a href=https://en.wikipedia.org/wiki/S-expression>S-expression</a>&rdquo;. For <code>(f a)</code>, it means that we are calling a function <code>f</code>, and it takes an argument <code>a</code>, and the <code>a</code> can also be another S-expression like <code>(x x)</code>.</p><p>So in Python, it&rsquo;s quite straight:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>lambda</span> x: f(x(x))
</code></pre></div><p>The latter <code>λx. (f (x x))</code> is definitely the same:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>lambda</span> x: f(x(x))
</code></pre></div><h3 id=outer-lambda>Outer lambda<a href=#outer-lambda class=hanchor arialabel=Anchor>&#8983;</a></h3><p>So, how do we put them together? Actually, <code>lambda x: f(x(x))</code> is a function, so we&rsquo;ll invoke this function whose argument is itself. I know it sounds cryptic, but for now we just try:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>( <span style=color:#66d9ef>lambda</span> x: f(x(x)) )  ( <span style=color:#66d9ef>lambda</span> x: f(x(x)) )
<span style=color:#75715e>#     function                argument</span>
</code></pre></div><p>Back to the outside, we&rsquo;ll get</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>Y <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> f: (<span style=color:#66d9ef>lambda</span> x: f(x(x)))(<span style=color:#66d9ef>lambda</span> x: f(x(x)))
</code></pre></div><h2 id=how-to-use-y-combinator>How to use Y-combinator<a href=#how-to-use-y-combinator class=hanchor arialabel=Anchor>&#8983;</a></h2><p>You may want to ask, how should we use this weird thing to implement recursion <strong>without</strong> defining any function? Well, let&rsquo;s take the factorial calculation as an example.</p><h3 id=first-try>First try<a href=#first-try class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Normally, you might write something like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fac</span>(n):
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> fac(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)

<span style=color:#66d9ef>print</span>(fac(<span style=color:#ae81ff>5</span>))  <span style=color:#75715e># 120</span>
</code></pre></div><p>However, what if you cannot name a function? Let&rsquo;s recap the rules of lambda calculus, we may notice there&rsquo;s no rule for naming or defining a function. So we have to find another way to emulate that.</p><p>One way is to substitute the recursion call with an argument representing the function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>fac <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> f: <span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> f(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</code></pre></div><p>You may wonder how to call it like in Python, in fact, this is why we need Y-combinator.</p><p>Let&rsquo;s try applying it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(Y(fac)(<span style=color:#ae81ff>5</span>))
</code></pre></div><p>Hmm&mldr;You should see:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>RecursionError: maximum recursion depth exceeded
</code></pre></div><h3 id=the-evaluation-problem-we-saw>The evaluation problem we saw<a href=#the-evaluation-problem-we-saw class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Wait, what is this? I&rsquo;m sorry I forgot to mention you&rsquo;d encounter with the error. It has something to do with the way how a programming language evaluates arguments passed into a function.</p><p>Say you have functions like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add1</span>(x):
    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mul</span>(x, y):
    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> y

<span style=color:#66d9ef>print</span>(mul(add1(<span style=color:#ae81ff>0</span>), add1(<span style=color:#ae81ff>1</span>))) <span style=color:#75715e># 2</span>
</code></pre></div><p>Let&rsquo;s ponder: When Python is calling <code>mul(add1(0), add1(1))</code>, how does Python evaluate its arguments? Some of you may answer quickly: it&rsquo;ll evaluate <code>add1(0)</code> and <code>add1(1)</code> first, and then <code>mul(1, 2)</code>!</p><p>Yes, that&rsquo;s almost right. Let&rsquo;s dig into something else. What if we call a function like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>(<span style=color:#66d9ef>lambda</span> y: (<span style=color:#66d9ef>lambda</span> x: x)(y))(<span style=color:#ae81ff>1</span>)
</code></pre></div><p>Obviously you&rsquo;ll see <code>1</code>, but in what order Python evaluates its arguments?</p><p>As mentioned above, Python will evaluate arguments eagerly, so it will become <code>(lambda x: x)(1)</code>, then <code>1</code>.</p><blockquote><p>This is called applicative order.</p></blockquote><p>This is why we got <code>RecursionError</code>. Let&rsquo;s review the <code>lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))</code> and call it with a simple <code>i = lambda f: lambda x: x</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>(<span style=color:#66d9ef>lambda</span> f: (<span style=color:#66d9ef>lambda</span> x: f(x(x)))(<span style=color:#66d9ef>lambda</span> x: f(x(x))))(i)
<span style=color:#75715e># will be evaluated to:</span>
(<span style=color:#66d9ef>lambda</span> x: i(x(x)))(<span style=color:#66d9ef>lambda</span> y: i(y(y)))  <span style=color:#75715e># let&#39;s rename to avoid ambiguity</span>
<span style=color:#75715e># endless recursion:</span>
i( <span style=color:#66d9ef>lambda</span> y: i(y(y)) )( <span style=color:#66d9ef>lambda</span> y: i(y(i(y(i(y(<span style=color:#f92672>...</span>)))))) )
</code></pre></div><p>Here when Python evaluates the argument <code>lambda y: i(y(y))</code>, it&rsquo;ll recursively call <code>y</code> as a function over and over again. Yet, how can we cease the endless recursion? Or how can we only recursively get it called just once or twice or thrice?</p><p>In effect, we&rsquo;d like to evaluate the function itself <strong>before</strong> any arguments get substituted.</p><blockquote><p>This is called normal order.</p></blockquote><p>Evaluation strategy is just a choice, and some typical functional languages behave like the normal order, however unfortunately, Python doesn&rsquo;t follow this style.</p><h3 id=the-way-to-delay-evaluation>The way to delay evaluation<a href=#the-way-to-delay-evaluation class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In order to delay the evaluation of an expression, what should we do? Say we don&rsquo;t want Python to evaluate <code>3 + 3</code> right now, we can wrap them into a function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>another_f <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span>: <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>
</code></pre></div><p>Thus, the <code>3 + 3</code> will only be evaluated when the function gets invoked as <code>another_f()</code>.</p><blockquote><p>It is called &ldquo;<a href=https://wiki.haskell.org/Eta_conversion>eta conversion</a>&rdquo; in lambda calculus, which can be regarded as saving some code for future execution.</p></blockquote><h3 id=z-combinator>Z-Combinator<a href=#z-combinator class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Back to the Y-combinator we wrote, the problem comes when Python evaluates our arguments too early, so we need to delay the evaluation of <code>x(x)</code> in the argument lambda:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>Y <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> f: (<span style=color:#66d9ef>lambda</span> x: f(x(x)))(<span style=color:#66d9ef>lambda</span> x: f(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: x(x)(<span style=color:#f92672>*</span>args)))
<span style=color:#66d9ef>print</span>(Y(fac)(<span style=color:#ae81ff>5</span>))  <span style=color:#75715e># 120</span>
</code></pre></div><blockquote><p>Eta-converted Y-combinator is called Z-combinator.</p></blockquote><p>It works! Let&rsquo;s examine it step by step.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># fac = lambda f: lambda n: 1 if n &lt;= 1 else n * f(n - 1)</span>
fy <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> y: fac(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: y(y)(<span style=color:#f92672>*</span>args))
fy1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> y1: fac(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: y1(y1)(<span style=color:#f92672>*</span>args))
<span style=color:#75715e># (lambda x: fac(x(x)))(lambda y: fac(lambda *args: y(y)(*args)))</span>
<span style=color:#75715e># will be evaluated to</span>
fac(fy(fy1))
<span style=color:#75715e># expand fy</span>
fac(fac(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args)))
<span style=color:#75715e># here the fy1 is captured into the closure</span>
fac(<span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> (<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args))(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</code></pre></div><p>So if you call <code>fy(fy)</code> or <code>fy(fy1)</code>, it&rsquo;ll not get trapped into endless recursion since inside <code>fy</code>, the <code>y</code> will not be invoked immediately. Instead, it&rsquo;ll just return the closure <code>lambda *args: y(y)(*args)</code>. Let&rsquo;s continue:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>ffac <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> (<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args))(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
<span style=color:#75715e># simplify</span>
fac(ffac)
<span style=color:#75715e># expand once again</span>
(<span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> ffac(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
<span style=color:#75715e># what abount n == 3?</span>
(<span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> ffac(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))(<span style=color:#ae81ff>3</span>)
<span style=color:#75715e># in else branch</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> ffac(<span style=color:#ae81ff>2</span>)
<span style=color:#75715e># expand ffac(2)</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> (<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args))(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e># eliminate args</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> fy1(fy1)(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e># substitute</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> fac(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args))(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e># just for simplicity</span>
zetafy1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: fy1(fy1)(<span style=color:#f92672>*</span>args)
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> fac(zetafy1)(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e># expand fac</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> (<span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> zetafy1(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))(<span style=color:#ae81ff>1</span>)
<span style=color:#75715e># in if branch</span>
<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># == 6</span>
</code></pre></div><p>The complicated part <code>zetafy1(n - 1)</code> disappeared like magic!</p><blockquote><p>Every magic can be explained. The recursion stops when falling into the basic case <code>n &lt;= 1</code>.</p></blockquote><h3 id=the-final-version-without-variables>The final version without variables<a href=#the-final-version-without-variables class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Remember we cannot define variables in lambda calculus? So we just remove variables and reach the final version:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(
  (<span style=color:#66d9ef>lambda</span> f: (<span style=color:#66d9ef>lambda</span> x: f(x(x)))
    (<span style=color:#66d9ef>lambda</span> x: f(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: x(x)(<span style=color:#f92672>*</span>args))))
  (<span style=color:#66d9ef>lambda</span> f: <span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> f(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))(<span style=color:#ae81ff>5</span>))  <span style=color:#75715e># 120</span>
</code></pre></div><p>How neat!</p><h3 id=other-variants>Other variants<a href=#other-variants class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=recursive>Recursive<a href=#recursive class=hanchor arialabel=Anchor>&#8983;</a></h4><p>However, if we are not that strict, we can define Y-combinator simply with recursion like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e># By fixed-point definition</span>
<span style=color:#75715e># Y = lambda f: f(Y(f))</span>
Z <span style=color:#f92672>=</span> <span style=color:#66d9ef>lambda</span> f: <span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: f(Z(f))(<span style=color:#f92672>*</span>args)  <span style=color:#75715e># eta converted to avoid endless recursion</span>
<span style=color:#66d9ef>print</span>(Z(<span style=color:#66d9ef>lambda</span> f: <span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> f(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))(<span style=color:#ae81ff>5</span>))  <span style=color:#75715e># 120</span>
</code></pre></div><h4 id=first-f-eliminated>First <code>f</code> eliminated<a href=#first-f-eliminated class=hanchor arialabel=Anchor>&#8983;</a></h4><p>You might have noticed that <code>fac(ffac)</code> is an overkill. What if we remove an <code>f</code>?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>print</span>(
  (<span style=color:#66d9ef>lambda</span> f: (<span style=color:#66d9ef>lambda</span> x: x(x))
    (<span style=color:#66d9ef>lambda</span> x: f(<span style=color:#66d9ef>lambda</span> <span style=color:#f92672>*</span>args: x(x)(<span style=color:#f92672>*</span>args))))
  (<span style=color:#66d9ef>lambda</span> f: <span style=color:#66d9ef>lambda</span> n: <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>if</span> n <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> n <span style=color:#f92672>*</span> f(n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))(<span style=color:#ae81ff>5</span>))  <span style=color:#75715e># 120</span>
</code></pre></div><p>You&rsquo;ll get the same result. If you&rsquo;d like to know why, evaluate it step by step.</p><h2 id=conclusion>Conclusion<a href=#conclusion class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Lambda calculus is concise, but it&rsquo;s profoundly connected with the essence of calculation. With Y-combinator, we are able to implement recursion as in Python without defining any variable and even <a href=https://github.com/kigawas/computation-py/tree/master/computation/interpreter>emulate a script language virtual machine</a>.</p></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//kigawas-blog.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div></body></html>